<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Mtn\Momo\Disbursement
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Disbursements
 *
 * Automatically deposit funds to multiple users
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Mtn\Momo\Disbursement\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Mtn\Momo\Disbursement\ApiException;
use Mtn\Momo\Disbursement\Configuration;
use Mtn\Momo\Disbursement\HeaderSelector;
use Mtn\Momo\Disbursement\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Mtn\Momo\Disbursement
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'bcAuthorize' => [
            'application/x-www-form-urlencoded',
        ],
        'createAccessToken' => [
            'application/json',
        ],
        'createOauth2Token' => [
            'application/x-www-form-urlencoded',
        ],
        'depositV1' => [
            'application/json',
        ],
        'depositV2' => [
            'application/json',
        ],
        'getAccountBalance' => [
            'application/json',
        ],
        'getAccountBalanceInSpecificCurrency' => [
            'application/json',
        ],
        'getBasicUserinfo' => [
            'application/json',
        ],
        'getDepositStatus' => [
            'application/json',
        ],
        'getRefundStatus' => [
            'application/json',
        ],
        'getTransferStatus' => [
            'application/json',
        ],
        'getUserInfoWithConsent' => [
            'application/json',
        ],
        'refundV1' => [
            'application/json',
        ],
        'refundV2' => [
            'application/json',
        ],
        'transfer' => [
            'application/json',
        ],
        'validateAccountHolderStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bcAuthorize
     *
     * bc-authorize
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $scope scope (optional)
     * @param  string $login_hint login_hint (optional)
     * @param  string $access_type access_type (optional)
     * @param  int $consent_valid_in consent_valid_in (optional)
     * @param  string $client_notification_token client_notification_token (optional)
     * @param  string $scope_instruction scope_instruction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\BcauthorizeResponse
     */
    public function bcAuthorize($authorization, $x_target_environment, $x_callback_url = null, $scope = null, $login_hint = null, $access_type = null, $consent_valid_in = null, $client_notification_token = null, $scope_instruction = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        list($response) = $this->bcAuthorizeWithHttpInfo($authorization, $x_target_environment, $x_callback_url, $scope, $login_hint, $access_type, $consent_valid_in, $client_notification_token, $scope_instruction, $contentType);
        return $response;
    }

    /**
     * Operation bcAuthorizeWithHttpInfo
     *
     * bc-authorize
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $scope (optional)
     * @param  string $login_hint (optional)
     * @param  string $access_type (optional)
     * @param  int $consent_valid_in (optional)
     * @param  string $client_notification_token (optional)
     * @param  string $scope_instruction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\BcauthorizeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bcAuthorizeWithHttpInfo($authorization, $x_target_environment, $x_callback_url = null, $scope = null, $login_hint = null, $access_type = null, $consent_valid_in = null, $client_notification_token = null, $scope_instruction = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        $request = $this->bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url, $scope, $login_hint, $access_type, $consent_valid_in, $client_notification_token, $scope_instruction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\BcauthorizeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\BcauthorizeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\BcauthorizeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\BcauthorizeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\BcauthorizeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bcAuthorizeAsync
     *
     * bc-authorize
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $scope (optional)
     * @param  string $login_hint (optional)
     * @param  string $access_type (optional)
     * @param  int $consent_valid_in (optional)
     * @param  string $client_notification_token (optional)
     * @param  string $scope_instruction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bcAuthorizeAsync($authorization, $x_target_environment, $x_callback_url = null, $scope = null, $login_hint = null, $access_type = null, $consent_valid_in = null, $client_notification_token = null, $scope_instruction = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        return $this->bcAuthorizeAsyncWithHttpInfo($authorization, $x_target_environment, $x_callback_url, $scope, $login_hint, $access_type, $consent_valid_in, $client_notification_token, $scope_instruction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bcAuthorizeAsyncWithHttpInfo
     *
     * bc-authorize
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $scope (optional)
     * @param  string $login_hint (optional)
     * @param  string $access_type (optional)
     * @param  int $consent_valid_in (optional)
     * @param  string $client_notification_token (optional)
     * @param  string $scope_instruction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bcAuthorizeAsyncWithHttpInfo($authorization, $x_target_environment, $x_callback_url = null, $scope = null, $login_hint = null, $access_type = null, $consent_valid_in = null, $client_notification_token = null, $scope_instruction = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\BcauthorizeResponse';
        $request = $this->bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url, $scope, $login_hint, $access_type, $consent_valid_in, $client_notification_token, $scope_instruction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bcAuthorize'
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  string $scope (optional)
     * @param  string $login_hint (optional)
     * @param  string $access_type (optional)
     * @param  int $consent_valid_in (optional)
     * @param  string $client_notification_token (optional)
     * @param  string $scope_instruction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bcAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bcAuthorizeRequest($authorization, $x_target_environment, $x_callback_url = null, $scope = null, $login_hint = null, $access_type = null, $consent_valid_in = null, $client_notification_token = null, $scope_instruction = null, string $contentType = self::contentTypes['bcAuthorize'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling bcAuthorize'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling bcAuthorize'
            );
        }









        $resourcePath = '/v1_0/bc-authorize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }


        // form params
        if ($scope !== null) {
            $formParams['scope'] = ObjectSerializer::toFormValue($scope);
        }
        // form params
        if ($login_hint !== null) {
            $formParams['login_hint'] = ObjectSerializer::toFormValue($login_hint);
        }
        // form params
        if ($access_type !== null) {
            $formParams['access_type'] = ObjectSerializer::toFormValue($access_type);
        }
        // form params
        if ($consent_valid_in !== null) {
            $formParams['consent_valid_in'] = ObjectSerializer::toFormValue($consent_valid_in);
        }
        // form params
        if ($client_notification_token !== null) {
            $formParams['client_notification_token'] = ObjectSerializer::toFormValue($client_notification_token);
        }
        // form params
        if ($scope_instruction !== null) {
            $formParams['scope_instruction'] = ObjectSerializer::toFormValue($scope_instruction);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccessToken
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse|\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse
     */
    public function createAccessToken($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        list($response) = $this->createAccessTokenWithHttpInfo($authorization, $contentType);
        return $response;
    }

    /**
     * Operation createAccessTokenWithHttpInfo
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse|\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccessTokenWithHttpInfo($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        $request = $this->createAccessTokenRequest($authorization, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccessTokenAsync
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccessTokenAsync($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        return $this->createAccessTokenAsyncWithHttpInfo($authorization, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccessTokenAsyncWithHttpInfo
     *
     * CreateAccessToken
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccessTokenAsyncWithHttpInfo($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\TokenPost200ApplicationJsonResponse';
        $request = $this->createAccessTokenRequest($authorization, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccessToken'
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAccessTokenRequest($authorization, string $contentType = self::contentTypes['createAccessToken'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createAccessToken'
            );
        }


        $resourcePath = '/token/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOauth2Token
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type grant_type (optional)
     * @param  string $auth_req_id auth_req_id (optional)
     * @param  string $refresh_token refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\Oauth2TokenResponse
     */
    public function createOauth2Token($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        list($response) = $this->createOauth2TokenWithHttpInfo($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);
        return $response;
    }

    /**
     * Operation createOauth2TokenWithHttpInfo
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\Oauth2TokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOauth2TokenWithHttpInfo($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        $request = $this->createOauth2TokenRequest($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOauth2TokenAsync
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOauth2TokenAsync($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        return $this->createOauth2TokenAsyncWithHttpInfo($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOauth2TokenAsyncWithHttpInfo
     *
     * CreateOauth2Token
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOauth2TokenAsyncWithHttpInfo($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\Oauth2TokenResponse';
        $request = $this->createOauth2TokenRequest($authorization, $x_target_environment, $grant_type, $auth_req_id, $refresh_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOauth2Token'
     *
     * @param  string $authorization Basic authentication header containing API user ID and API key. Should be sent in as B64 encoded. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $grant_type (optional)
     * @param  string $auth_req_id (optional)
     * @param  string $refresh_token (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOauth2Token'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOauth2TokenRequest($authorization, $x_target_environment, $grant_type = null, $auth_req_id = null, $refresh_token = null, string $contentType = self::contentTypes['createOauth2Token'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createOauth2Token'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling createOauth2Token'
            );
        }





        $resourcePath = '/oauth2/token/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }


        // form params
        if ($grant_type !== null) {
            $formParams['grant_type'] = ObjectSerializer::toFormValue($grant_type);
        }
        // form params
        if ($auth_req_id !== null) {
            $formParams['auth_req_id'] = ObjectSerializer::toFormValue($auth_req_id);
        }
        // form params
        if ($refresh_token !== null) {
            $formParams['refresh_token'] = ObjectSerializer::toFormValue($refresh_token);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation depositV1
     *
     * Deposit-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function depositV1($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV1'][0])
    {
        $this->depositV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);
    }

    /**
     * Operation depositV1WithHttpInfo
     *
     * Deposit-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function depositV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV1'][0])
    {
        $request = $this->depositV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation depositV1Async
     *
     * Deposit-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function depositV1Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV1'][0])
    {
        return $this->depositV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation depositV1AsyncWithHttpInfo
     *
     * Deposit-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function depositV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV1'][0])
    {
        $returnType = '';
        $request = $this->depositV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'depositV1'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function depositV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV1'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling depositV1'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling depositV1'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling depositV1'
            );
        }




        $resourcePath = '/v1_0/deposit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Incorrect currency for target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer));
            } else {
                $httpBody = $transfer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation depositV2
     *
     * Deposit-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function depositV2($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV2'][0])
    {
        $this->depositV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);
    }

    /**
     * Operation depositV2WithHttpInfo
     *
     * Deposit-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function depositV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV2'][0])
    {
        $request = $this->depositV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation depositV2Async
     *
     * Deposit-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function depositV2Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV2'][0])
    {
        return $this->depositV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation depositV2AsyncWithHttpInfo
     *
     * Deposit-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function depositV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV2'][0])
    {
        $returnType = '';
        $request = $this->depositV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'depositV2'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request-to-pay transaction. This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['depositV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function depositV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['depositV2'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling depositV2'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling depositV2'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling depositV2'
            );
        }




        $resourcePath = '/v2_0/deposit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Incorrect currency for target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer));
            } else {
                $httpBody = $transfer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountBalance
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\Balance|\Mtn\Momo\Disbursement\Model\ErrorReason
     */
    public function getAccountBalance($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        list($response) = $this->getAccountBalanceWithHttpInfo($authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getAccountBalanceWithHttpInfo
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\Balance|\Mtn\Momo\Disbursement\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountBalanceWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        $request = $this->getAccountBalanceRequest($authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\Balance' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\Balance' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\Balance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\Balance';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\Balance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountBalanceAsync
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceAsync($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        return $this->getAccountBalanceAsyncWithHttpInfo($authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountBalanceAsyncWithHttpInfo
     *
     * GetAccountBalance
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceAsyncWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\Balance';
        $request = $this->getAccountBalanceRequest($authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountBalance'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAccountBalanceRequest($authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalance'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getAccountBalance'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getAccountBalance'
            );
        }


        $resourcePath = '/v1_0/account/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountBalanceInSpecificCurrency
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\Balance|\Mtn\Momo\Disbursement\Model\ErrorReason
     */
    public function getAccountBalanceInSpecificCurrency($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        list($response) = $this->getAccountBalanceInSpecificCurrencyWithHttpInfo($currency, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyWithHttpInfo
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\Balance|\Mtn\Momo\Disbursement\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountBalanceInSpecificCurrencyWithHttpInfo($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        $request = $this->getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\Balance' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\Balance' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\Balance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\Balance';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\Balance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyAsync
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceInSpecificCurrencyAsync($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        return $this->getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo($currency, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo
     *
     * GetAccountBalanceInSpecificCurrency
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountBalanceInSpecificCurrencyAsyncWithHttpInfo($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\Balance';
        $request = $this->getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountBalanceInSpecificCurrency'
     *
     * @param  string $currency Should be in ISO4217 Currency (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountBalanceInSpecificCurrency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAccountBalanceInSpecificCurrencyRequest($currency, $authorization, $x_target_environment, string $contentType = self::contentTypes['getAccountBalanceInSpecificCurrency'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getAccountBalanceInSpecificCurrency'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getAccountBalanceInSpecificCurrency'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getAccountBalanceInSpecificCurrency'
            );
        }


        $resourcePath = '/v1_0/account/balance/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBasicUserinfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.Possible values:MSISDN Email AliasID (account ID) (required)
     * @param  string $account_holder_id string (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse|\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse
     */
    public function getBasicUserinfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        list($response) = $this->getBasicUserinfoWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getBasicUserinfoWithHttpInfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.Possible values:MSISDN Email AliasID (account ID) (required)
     * @param  string $account_holder_id string (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse|\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBasicUserinfoWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        $request = $this->getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\TokenPost401ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBasicUserinfoAsync
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.Possible values:MSISDN Email AliasID (account ID) (required)
     * @param  string $account_holder_id string (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicUserinfoAsync($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        return $this->getBasicUserinfoAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBasicUserinfoAsyncWithHttpInfo
     *
     * GetBasicUserinfo
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.Possible values:MSISDN Email AliasID (account ID) (required)
     * @param  string $account_holder_id string (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBasicUserinfoAsyncWithHttpInfo($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\BasicUserInfoJsonResponse';
        $request = $this->getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBasicUserinfo'
     *
     * @param  string $account_holder_id_type Type of account holder identity passed in accountHolderId path param.Possible values:MSISDN Email AliasID (account ID) (required)
     * @param  string $account_holder_id string (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBasicUserinfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBasicUserinfoRequest($account_holder_id_type, $account_holder_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getBasicUserinfo'][0])
    {

        // verify the required parameter 'account_holder_id_type' is set
        if ($account_holder_id_type === null || (is_array($account_holder_id_type) && count($account_holder_id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id_type when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'account_holder_id' is set
        if ($account_holder_id === null || (is_array($account_holder_id) && count($account_holder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getBasicUserinfo'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getBasicUserinfo'
            );
        }


        $resourcePath = '/v1_0/accountholder/{accountHolderIdType}/{accountHolderId}/basicuserinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($account_holder_id_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderIdType' . '}',
                ObjectSerializer::toPathValue($account_holder_id_type),
                $resourcePath
            );
        }
        // path params
        if ($account_holder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderId' . '}',
                ObjectSerializer::toPathValue($account_holder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDepositStatus
     *
     * GetDepositStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Deposit. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDepositStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\TransferResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason
     */
    public function getDepositStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getDepositStatus'][0])
    {
        list($response) = $this->getDepositStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getDepositStatusWithHttpInfo
     *
     * GetDepositStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Deposit. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDepositStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\TransferResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDepositStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getDepositStatus'][0])
    {
        $request = $this->getDepositStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\TransferResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\TransferResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\TransferResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\TransferResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\TransferResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDepositStatusAsync
     *
     * GetDepositStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Deposit. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDepositStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getDepositStatus'][0])
    {
        return $this->getDepositStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDepositStatusAsyncWithHttpInfo
     *
     * GetDepositStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Deposit. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDepositStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getDepositStatus'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\TransferResult';
        $request = $this->getDepositStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDepositStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Deposit. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDepositStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDepositStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getDepositStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling getDepositStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getDepositStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getDepositStatus'
            );
        }


        $resourcePath = '/v1_0/deposit/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful transfer', 'Payer limit breached', 'API user insufficient balance', 'application/json', 'Transfer not found', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRefundStatus
     *
     * GetRefundStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Refund. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRefundStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\RefundResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason
     */
    public function getRefundStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getRefundStatus'][0])
    {
        list($response) = $this->getRefundStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getRefundStatusWithHttpInfo
     *
     * GetRefundStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Refund. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRefundStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\RefundResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRefundStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getRefundStatus'][0])
    {
        $request = $this->getRefundStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\RefundResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\RefundResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\RefundResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\RefundResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\RefundResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRefundStatusAsync
     *
     * GetRefundStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Refund. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRefundStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRefundStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getRefundStatus'][0])
    {
        return $this->getRefundStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRefundStatusAsyncWithHttpInfo
     *
     * GetRefundStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Refund. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRefundStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRefundStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getRefundStatus'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\RefundResult';
        $request = $this->getRefundStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRefundStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Refund. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRefundStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRefundStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getRefundStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling getRefundStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getRefundStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getRefundStatus'
            );
        }


        $resourcePath = '/v1_0/refund/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful transfer', 'Payer limit breached', 'API user insufficient balance', 'application/json', 'Transfer not found', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransferStatus
     *
     * GetTransferStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Transfer. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransferStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\TransferResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason
     */
    public function getTransferStatus($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getTransferStatus'][0])
    {
        list($response) = $this->getTransferStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getTransferStatusWithHttpInfo
     *
     * GetTransferStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Transfer. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransferStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\TransferResult|\Mtn\Momo\Disbursement\Model\ErrorReason|\Mtn\Momo\Disbursement\Model\ErrorReason, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransferStatusWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getTransferStatus'][0])
    {
        $request = $this->getTransferStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\TransferResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\TransferResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\TransferResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Mtn\Momo\Disbursement\Model\ErrorReason' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ErrorReason' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ErrorReason', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\TransferResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\TransferResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransferStatusAsync
     *
     * GetTransferStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Transfer. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransferStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransferStatusAsync($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getTransferStatus'][0])
    {
        return $this->getTransferStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransferStatusAsyncWithHttpInfo
     *
     * GetTransferStatus
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Transfer. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransferStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransferStatusAsyncWithHttpInfo($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getTransferStatus'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\TransferResult';
        $request = $this->getTransferStatusRequest($reference_id, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransferStatus'
     *
     * @param  string $reference_id UUID of transaction to get result. Reference id  used when creating the Transfer. (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransferStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTransferStatusRequest($reference_id, $authorization, $x_target_environment, string $contentType = self::contentTypes['getTransferStatus'][0])
    {

        // verify the required parameter 'reference_id' is set
        if ($reference_id === null || (is_array($reference_id) && count($reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_id when calling getTransferStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getTransferStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getTransferStatus'
            );
        }


        $resourcePath = '/v1_0/transfer/{referenceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($reference_id !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceId' . '}',
                ObjectSerializer::toPathValue($reference_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Successful transfer', 'Payer limit breached', 'API user insufficient balance', 'application/json', 'Transfer not found', 'Unspecified internal error', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserInfoWithConsent
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Mtn\Momo\Disbursement\Model\ConsentkycResponse
     */
    public function getUserInfoWithConsent($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        list($response) = $this->getUserInfoWithConsentWithHttpInfo($authorization, $x_target_environment, $contentType);
        return $response;
    }

    /**
     * Operation getUserInfoWithConsentWithHttpInfo
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Mtn\Momo\Disbursement\Model\ConsentkycResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserInfoWithConsentWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        $request = $this->getUserInfoWithConsentRequest($authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Mtn\Momo\Disbursement\Model\ConsentkycResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Mtn\Momo\Disbursement\Model\ConsentkycResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Mtn\Momo\Disbursement\Model\ConsentkycResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Mtn\Momo\Disbursement\Model\ConsentkycResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ConsentkycResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserInfoWithConsentAsync
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoWithConsentAsync($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        return $this->getUserInfoWithConsentAsyncWithHttpInfo($authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserInfoWithConsentAsyncWithHttpInfo
     *
     * GetUserInfoWithConsent
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoWithConsentAsyncWithHttpInfo($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {
        $returnType = '\Mtn\Momo\Disbursement\Model\ConsentkycResponse';
        $request = $this->getUserInfoWithConsentRequest($authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserInfoWithConsent'
     *
     * @param  string $authorization Bearer Token. Replace with a valid oauth2 token received from oauth2 token endpoint in Wallet Platform. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfoWithConsent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserInfoWithConsentRequest($authorization, $x_target_environment, string $contentType = self::contentTypes['getUserInfoWithConsent'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getUserInfoWithConsent'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling getUserInfoWithConsent'
            );
        }


        $resourcePath = '/oauth2/v1_0/userinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refundV1
     *
     * Refund-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function refundV1($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV1'][0])
    {
        $this->refundV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);
    }

    /**
     * Operation refundV1WithHttpInfo
     *
     * Refund-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV1'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function refundV1WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV1'][0])
    {
        $request = $this->refundV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refundV1Async
     *
     * Refund-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundV1Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV1'][0])
    {
        return $this->refundV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refundV1AsyncWithHttpInfo
     *
     * Refund-V1
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundV1AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV1'][0])
    {
        $returnType = '';
        $request = $this->refundV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refundV1'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (POST Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refundV1Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV1'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling refundV1'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling refundV1'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling refundV1'
            );
        }




        $resourcePath = '/v1_0/refund';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Incorrect currency for target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($refund)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($refund));
            } else {
                $httpBody = $refund;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refundV2
     *
     * Refund-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function refundV2($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV2'][0])
    {
        $this->refundV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);
    }

    /**
     * Operation refundV2WithHttpInfo
     *
     * Refund-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV2'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function refundV2WithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV2'][0])
    {
        $request = $this->refundV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refundV2Async
     *
     * Refund-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundV2Async($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV2'][0])
    {
        return $this->refundV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refundV2AsyncWithHttpInfo
     *
     * Refund-V2
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundV2AsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV2'][0])
    {
        $returnType = '';
        $request = $this->refundV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $refund, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refundV2'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID.  This ID is used for e.g. validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url (PUT Method)URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Refund $refund (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refundV2Request($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $refund = null, string $contentType = self::contentTypes['refundV2'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling refundV2'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling refundV2'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling refundV2'
            );
        }




        $resourcePath = '/v2_0/refund';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Incorrect currency for target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($refund)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($refund));
            } else {
                $httpBody = $refund;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transfer
     *
     * Transfer
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfer'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transfer($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['transfer'][0])
    {
        $this->transferWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);
    }

    /**
     * Operation transferWithHttpInfo
     *
     * Transfer
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfer'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['transfer'][0])
    {
        $request = $this->transferRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferAsync
     *
     * Transfer
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferAsync($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['transfer'][0])
    {
        return $this->transferAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferAsyncWithHttpInfo
     *
     * Transfer
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferAsyncWithHttpInfo($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['transfer'][0])
    {
        $returnType = '';
        $request = $this->transferRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url, $transfer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transfer'
     *
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_reference_id Format - UUID. Recource ID of the created request to pay transaction. This ID is used, for example validating the status of the request. Universal Unique ID for the transaction generated using UUID version 4. (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $x_callback_url URL to the server where the callback should be sent. (optional)
     * @param  \Mtn\Momo\Disbursement\Model\Transfer $transfer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferRequest($authorization, $x_reference_id, $x_target_environment, $x_callback_url = null, $transfer = null, string $contentType = self::contentTypes['transfer'][0])
    {

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling transfer'
            );
        }

        // verify the required parameter 'x_reference_id' is set
        if ($x_reference_id === null || (is_array($x_reference_id) && count($x_reference_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_reference_id when calling transfer'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling transfer'
            );
        }




        $resourcePath = '/v1_0/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_callback_url !== null) {
            $headerParams['X-Callback-Url'] = ObjectSerializer::toHeaderValue($x_callback_url);
        }
        // header params
        if ($x_reference_id !== null) {
            $headerParams['X-Reference-Id'] = ObjectSerializer::toHeaderValue($x_reference_id);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'ReferenceId already in use', 'Incorrect currency for target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer));
            } else {
                $httpBody = $transfer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateAccountHolderStatus
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolderID type. &lt;br&gt; MSISDN - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; EMAIL - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolderID. Allowed values [msisdn, email] (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateAccountHolderStatus($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $this->validateAccountHolderStatusWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);
    }

    /**
     * Operation validateAccountHolderStatusWithHttpInfo
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolderID type. &lt;br&gt; MSISDN - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; EMAIL - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolderID. Allowed values [msisdn, email] (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \Mtn\Momo\Disbursement\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateAccountHolderStatusWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $request = $this->validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mtn\Momo\Disbursement\Model\ErrorReason',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateAccountHolderStatusAsync
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolderID type. &lt;br&gt; MSISDN - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; EMAIL - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolderID. Allowed values [msisdn, email] (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAccountHolderStatusAsync($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        return $this->validateAccountHolderStatusAsyncWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateAccountHolderStatusAsyncWithHttpInfo
     *
     * ValidateAccountHolderStatus
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolderID type. &lt;br&gt; MSISDN - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; EMAIL - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolderID. Allowed values [msisdn, email] (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAccountHolderStatusAsyncWithHttpInfo($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {
        $returnType = '';
        $request = $this->validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateAccountHolderStatus'
     *
     * @param  string $account_holder_id The AccountHolder number. Validated according to the AccountHolderID type. &lt;br&gt; MSISDN - Mobile Number validated according to ITU-T E.164. Validated with IsMSISDN&lt;br&gt; EMAIL - Validated to be a valid e-mail format. Validated with IsEmail (required)
     * @param  string $account_holder_id_type Specifies the type of the AccountHolderID. Allowed values [msisdn, email] (required)
     * @param  string $authorization Bearer Authentication Token generated using CreateAccessToken API Call (required)
     * @param  string $x_target_environment The identifier of the Wallet Platform system where the transaction shall be processed. This parameter is used to route the request to the Wallet Platform system that will initiate the transaction. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAccountHolderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateAccountHolderStatusRequest($account_holder_id, $account_holder_id_type, $authorization, $x_target_environment, string $contentType = self::contentTypes['validateAccountHolderStatus'][0])
    {

        // verify the required parameter 'account_holder_id' is set
        if ($account_holder_id === null || (is_array($account_holder_id) && count($account_holder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'account_holder_id_type' is set
        if ($account_holder_id_type === null || (is_array($account_holder_id_type) && count($account_holder_id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_holder_id_type when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling validateAccountHolderStatus'
            );
        }

        // verify the required parameter 'x_target_environment' is set
        if ($x_target_environment === null || (is_array($x_target_environment) && count($x_target_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_target_environment when calling validateAccountHolderStatus'
            );
        }


        $resourcePath = '/v1_0/accountholder/{accountHolderIdType}/{accountHolderId}/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($x_target_environment !== null) {
            $headerParams['X-Target-Environment'] = ObjectSerializer::toHeaderValue($x_target_environment);
        }

        // path params
        if ($account_holder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderId' . '}',
                ObjectSerializer::toPathValue($account_holder_id),
                $resourcePath
            );
        }
        // path params
        if ($account_holder_id_type !== null) {
            $resourcePath = str_replace(
                '{' . 'accountHolderIdType' . '}',
                ObjectSerializer::toPathValue($account_holder_id_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['Incorrect target environment', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
